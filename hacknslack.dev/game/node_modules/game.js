var Encounter     = require('encounter');
var Adventure     = require('adventure');
var globalActions = require('globalActions');
var tools         = require('tools');

var fs = require("fs");
var _  = require("lodash");

/**
 * A Game is a single execution of a player interaction with the system
 *
 * @param req
 * @constructor
 */
var Game = function( req ) {

  // request query - url $_GET vars placed into an object
  this.query = req.query;

  // request raw text input
  this.raw_input = req.query.text;

  // single game instance actions that the player can perform
  this.allowed_actions =  {}; // dynamically populated by system

  // the current player of this game
  this.player    = {};

  // the player's current character
  this.character = {};

  // the character's current adventure
  this.adventure = {};

  // the adventure's current encounter
  this.encounter = {};

  // response
  this.messages =  {
    // final output sent to player
    payload: '',
    // content that will be processed into the payload for output
    output:  [],
    // array of data for json endpoint
    debug: [],
    // error messages
    errors: []
  };

  /**
   * Get the next encounter on the current adventure
   */
  this.nextEncounter = function(){
    var next = parseInt( this.character.current_encounter ) + 1;

    // TODO
    if ( this.adventure.encounters[ next ]){
      this.debug('*** GOING TO NEXT ENCOUNTER ***');
      var stub = this.adventure.encounters[ next ];
      console.log(stub);
      // increment to next encounter
      this.encounter = Encounter.create( stub );
      this.character.current_encounter = next;
    }
    else {
      this.debug('*** GENERATING NEW ADVENTURE ***');
      // generate a new adventure
      this.adventure = this.generateAdventure();

      this.output("You have arrived at: " + this.adventure.title + "!");
      this.output(this.adventure.desc);
      // set the game encounter
      this.encounter = Encounter.create( this.adventure.encounters[0] );

      this.debug(this.adventure);
      // reset current encounter
      this.character.current_encounter = 0;
    }

    this.character.expireBuffs();
  };

  /**
   * Create the next adventure
   */
  this.generateAdventure = function(){
    var adventures = tools.files.getAllAdventures();
    var i = adventures.indexOf(this.adventure);
    if (i != -1) {
      adventures.splice(i,1);
    }

    var adventureStub = adventures[tools.random(0,adventures.length-1)];

    // add the encounters to the stub before constructing the adventure object
    adventureStub.encounters = this.generateEncounters(adventureStub);

    var adventure = Adventure.create(adventureStub);
    console.log("***TRYING TO BE ON ADVENTURE: " + adventure.title);
    
    return adventure;
  };

  /**
   * Generate random encounters
   *
   */
  this.generateEncounters = function(adventure){
    console.log("***GENERATING ENCOUNTERS FOR adventure: "+adventure.title);

    var used = [];
    var num_of_encounters = 5;
    var filtered_encounters = [];
    var encounters = [];
    
    // load encounter stubs
    var all_encounters = tools.files.getAllEncounters();

    // TODO - in the far and distant future, this would be much more efficient as a db call
    all_encounters.forEach( function(possible_encounter) {
      adventure.tags.forEach( function(tag) {
        if(possible_encounter.tags && possible_encounter.tags.indexOf(tag) != -1) {
          filtered_encounters.push(possible_encounter);
        }
      });
    });

    // make sure that we don't ever request more encounters than actually exist
    if ( filtered_encounters.length < num_of_encounters ){
      num_of_encounters = filtered_encounters.length;
    }

    console.log('---*** FOUND ' + filtered_encounters.length + ' encounters with the tags: ' + adventure.tags.join(', '));
    
    // loop through filtered encounters and randomly select a few
    while ( used.length < num_of_encounters ){
      // get a random encounter stub
      var rand = tools.random(0, filtered_encounters.length);

      // make sure we haven't used this encounter in the adventure so far
      if ( used.indexOf( rand ) === -1 ) {
        // keep track of encounters we've selected
        used.push(rand);

        var stub = filtered_encounters[rand];

        // make into full encounter
        var encounter = Encounter.create( stub );

        encounter.challenge.rating = tools.random(3, 7);

        // create fail effects
        encounter.fail.push({amount: 1, type: 'dmg'});
        encounter.fail.push({amount: 10, type: 'xp'});

        // create success effects
        encounter.success.push({amount: 1, type: 'heal'});
        encounter.success.push({amount: 17, type: 'xp'});

        console.log('----****--- ADDING encounter '+ encounter.title + ' to adventure');
        // add effects ?

        // add to adventure
        encounters.push(encounter);
      }
    }

    return encounters;
  };


  /**
   * Get the actions provided by an object and place into Game.allowed_actions
   *
   * @param obj
   * @param context
   */
  this.getActions = function( obj, context ) {
    if ( obj.actions ) {

      for (var i = 0; i < obj.actions.length; i++) {
        // can be a string, array, or action object
        var action = obj.actions[i];

        // strings are references to global actions
        if (typeof action === 'string' &&  globalActions.actions[ action ]) {
          this.allowed_actions[ action ] = globalActions.actions[ action ];
          this.allowed_actions[ action ].context = 'global';
        }
        // actions may alias global actions
        else if ( action.alias && globalActions.actions[ action.cmd ] ) {
          // the alias is what the user can type, so
          this.allowed_actions[ action.alias ] = _.clone(globalActions.actions[ action.cmd ]);
          this.allowed_actions[ action.alias ].alias = action.alias; // useful for debugging
          this.allowed_actions[ action.alias ].context = 'global';
          this.allowed_actions[ action.alias ].text = action.text;
        }
        // this action is unique to the context
        else {
          this.allowed_actions[ action.cmd ] = action;
          this.allowed_actions[ action.cmd ].context = context;
        }
        console.log('got actions for context: ' + context);
      }
    }
  };

  /**
   * Execute a the current Game action
   *
   * @param done
   */
  this.doAction = function( action, done ){

    console.log('------------ DO ACTION -----------');
    console.log( action );

    var _this = this;
    var context_map = {
      global: globalActions,
      player: this.player,
      adventure: this.adventure,
      character_class: this.character.class,
      encounter: this.encounter
      // TODO equipment and items
    };

    // get the contextual object of this action
    if ( context_map[ action.context ] ) {
      var context = context_map[ action.context ];

      console.log('-------------- ACTION CONTEXT OBJECT -------------');
      console.log( context );

      var method = '';

      if ( typeof context[ action.cmd ] === 'function' ){
        method = action.cmd;

        // execute the context's method
        context[ method ]( _this, function(){
          done();
        });
      }
      else {
        console.log('----------- Method not found in context -----------');
      }
    }
  };

  /**
   * Execute an effect object
   *
   * @param effect object
   */
  this.doEffect = function( effect ){
    if ( effect.type ) {
      switch ( effect.type ){
        case 'heal':
          var gain = effect.amount;

          if ( (this.character.hp + gain) > this.character.getAttrTotal('hp') ){
            gain = this.character.getAttrTotal('hp') - this.character.hp;
          }

          this.character.hp += gain;
          this.output('You gained ' + gain + ' HP!');
          break;

        case 'dmg':
          this.character.hp -= effect.amount;
          this.output('You were damaged for ' + effect.amount + ' HP!');
          break;

        case 'items':
          break;

        case 'bonus':
          break;

        case 'attack': // ???
          break;

        case 'output':
          this.output( effect.amount );
          break;

        case 'xp':
          this.character.xp += parseInt( effect.amount );
          this.output('You gained ' + effect.amount + ' XP!');
          break;

        case 'gp':
          this.character.gp += parseInt( effect.amount );
          this.output('You gained ' + effect.amount + ' GOLD!');
          break;

        case 'buff':
          this.character.addBuff( effect.amount );
          this.output(effect.amount.amount + ' to your ' + effect.amount.attribute + '!');
          break;

        default:
          break;
      }
    }
  };

  /**
   * Load a new adventure from file and start at first encounter
   */
  this.startAdventure = function( adventureFileName ){
    var stub = tools.files.getAdventure( adventureFileName );

    this.adventure = Adventure.create( stub );

    this.character.current_encounter = 0;
    this.encounter = Encounter.create( this.adventure.encounters[0] );
  };

  /**
   * Enqueue content that should be output to the player
   *
   * @param message
   */
  this.output = function( message ){
    this.messages.output.push( message );
  };

  /**
   * Enqueue data for debugging
   *
   * @param data - content or data to show the debugger
   */
  this.debug = function( data ){
    this.messages.debug.push( data );
  };

  /**
   * Handle errors ... eventually.
   * Currently 'errors' are text the player will see
   */
  this.error = function( error ){
    this.messages.errors.push( error );
  }
};

module.exports = Game;
