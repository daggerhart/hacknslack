/**
 *
 * character = {
 *   // (string) - unique character class
 *   class: String,
 *
 *   // (Number) - character level
 *   level: 1,
 *
 *   // (array of strings) - refer to global actions this character can perform
 *   actions: ['status', 'equip'],
 *
 *   // (object) of specific properties, each property's value is an item object
 *   equipment: {
 *     weapon: {item},
 *     armor: {item},
 *     gear: {item}
 *   },
 *
 *   // (object) of specific properties, each property's value is a number
 *   attributes: {
 *     body: Number,
 *     mind: Number,
 *     spirit: Number,
 *     hp: Number
 *   },
 *
 *   // (array) of item objects
 *   items:[
 *     {item},
 *     {item}
 *   ],
 *
 *   // (adventure object) - the character's current adventure
 *   adventure: {},
 *
 *   // (Number) - encounter array index
 *   // current_encounter: 0,
 * }
 */
var _ = require('lodash');
var Buff = require('buff');
var tools = require('tools');
var Item = require('item');

/**
 * Constructor provides default values for properties
 */
var Character = function(){
  // character's name
  this.name = '';

  // class object this character uses
  this.class = {};

  // character's current level of progression
  this.level = 0;

  // character's current experience points
  this.xp = 0;

  // character's current gold / money
  this.gp = 0;

  // character's current hp
  this.hp = 1;

  // actions this character can perform
  this.actions = [];

  // character's items that act as equipment
  this.equipment = {
    weapon: {},
    armor: {},
    gear: {}
  };

  // character's base attributes
  this.attributes = {
    body: 0,
    mind: 0,
    spirit: 0,
    hp: 0
  };

  // the buff objects attached to this character
  this.buffs = [];

  // character items
  this.items = [];

  // tags are arbitrary & unique words or phrases that
  // can represent an arbitrary character state.
  // eg, "hasSomeMagicItem"
  this.tags = [];

  // character's current adventure
  this.adventure = {};

  // character's current encounter index
  this.current_encounter = 0;
};

/**
 * Prototype of object contains default methods for all Character objects
 */
Character.prototype = {
  /**
   * Level up the character
   */
  levelUp: function () {
    this.xp = 0;
    this.level++;
    console.log("You have reached a new level of skill!");
    console.log("You are now a level "+this.level+" "+this.class.name+"!");

    // body
    if (this.class.attributes.body == "strong") {
      if (tools.random(0,1)) this.attributes.body++;
      this.attributes.body++;
    } else if (this.class.attributes.body == "weak") {
      if (tools.random(0,1)) this.attributes.body++;
    } else {
      this.attributes.body++;
    }

    // mind
    if (this.class.attributes.mind == "strong") {
      if (tools.random(0,1)) this.attributes.mind++;
      this.attributes.mind++;
    } else if (this.class.attributes.mind == "weak") {
      if (tools.random(0,1)) this.attributes.mind++;
    } else {
      this.attributes.mind++;
    }

    // spirit
    if (this.class.attributes.spirit == "strong") {
      if (tools.random(0,1)) this.attributes.spirit++;
      this.attributes.spirit++;
    } else if (this.class.attributes.spirit == "weak") {
      if (tools.random(0,1)) this.attributes.spirit++;
    } else {
      this.attributes.spirit++;
    }

    // hp
    if (this.class.attributes.hp == "strong") {
      if (tools.random(0,1)) this.attributes.hp++;
      this.attributes.hp++;
    } else if (this.class.attributes.hp == "weak") {
      if (tools.random(0,1)) this.attributes.hp++;
    } else {
      this.attributes.hp++;
    }
  },

  /**
   * Get an attribute's base value
   *
   * @param attr
   * @returns {*}
   */
  getAttr: function( attr ){
    if ( this.attributes[ attr ] ) {
      return this.attributes[ attr ];
    }

    return 0;
  },

  /**
   * Get the buff value of an attribute
   *
   * @param attr
   * @return int
   */
  getAttrBuff: function( attr ){
    if ( this.buff_totals[ attr ] ){
      return this.buff_totals[ attr ];
    }

    return 0;
  },

  /**
   * Get the total value of an attribute and its buffs
   *
   * @param attr
   * @return integer
   */
  getAttrTotal: function( attr ) {
    return this.getAttr( attr ) + this.getAttrBuff( attr );
  },

  /**
   * Gather the bonuses/buffs for this character into the this.buffs object
   */
  getBuffTotals: function( buffs ) {
    var buff_totals = {
      body: 0,
      mind: 0,
      spirit: 0,
      hp: 0
    };

    for( var i = 0; i < buffs.length; i++ ){
      // this buff object
      var buff = buffs[ i ];

      if ( this.attributes[ buff.attribute ] ) {
        // add the buff value to the totals
        buff_totals[ buff.attribute ] += buff.value;
      }
    }

    return buff_totals;
  },

  /**
   * Add a new buff to this character
   *
   * @param stub
   * @returns {Character}
   */
  addBuff: function( stub ){
    var buff = new Buff( stub );
    this.buffs.push( buff );

    // chain
    return this;
  },

  /**
   * Check to see if the character has a specific buff by name
   *
   * @param name
   * @returns {boolean}
   */
  hasBuff: function( name ){
    for( var i = 0; i < this.buffs.length; i++ ){
      var buff = this.buffs[ i ];
      if (buff.name == name){
        return true;
      }
    }
    return false;
  },

  /**
   * Decrement the duration of each buff, and remove any that have expired
   */
  expireBuffs: function(){
    var remaining_buffs = [];

    if ( this.buffs.length ){
      for ( var i = 0; i < this.buffs.length; i ++ ) {
        var buff = this.buffs[ i ];

        buff.duration = parseInt( buff.duration ) - 1;

        if ( buff.duration !== 0 ){
          remaining_buffs.push(buff);
        }
      }
    }

    this.buffs = remaining_buffs;
  },

  /**
   * Add Item to this character
   *
   * @param stub
   */
  addItem: function( stub ){
    var item = Item.create( stub );

    this.items.push( item );
  },

  /**
   * Remove a number of items from the character's inventory
   *
   * @param name - Item name
   * @param count - Number of items to remove
   * @returns {number}
   */
  removeItem: function( name, count ){
    var removed = 0;
    var _this = this;
    _.forEach( this.items, function( item, index ){
      if ( item.name == name && remove >= count ){
        _this.items.splice( index, 1);
        removed++;
      }
    });

    return removed;
  }
};

/**
 * Object factor produces a new object, merges stub information, and does preprocessing
 */
Character.create = function( stub ){
  var character = new Character( stub );

  // merge stub into object
  if ( typeof stub === 'object' ) {
    _.merge(character, stub );
  }

  // initial gathering of the buff totals.
  character.buff_totals = character.getBuffTotals( character.buffs );

  // add tags array if missing, and attach tag methods
  tools.initTags( character );

  return character;
};


module.exports = Character;